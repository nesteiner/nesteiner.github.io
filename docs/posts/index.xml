<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - My New Hugo Site</title>
        <link>http://example.org/posts/</link>
        <description>All Posts | My New Hugo Site</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 30 Dec 2022 23:34:00 &#43;0800</lastBuildDate><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Rust Scraper 简单使用</title>
    <link>http://example.org/posts/2022/12/rust-scraper/</link>
    <pubDate>Fri, 30 Dec 2022 23:34:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/12/rust-scraper/</guid>
    <description><![CDATA[Rust Scraper 从一段代码开始看起 fn main() { let response = reqwest::blocking::get( &#34;https://meitulu.me/item/4756.html&#34; ) .unwrap() .text() .unwrap(); let document = scraper::Html::parse_document(&amp;response); let image_selector = scraper::Selector::parse(&#34;div.mb-4.container-inner-fix-m img&#34;).unwrap(); let images = document.select(&amp;image_selector); images.for_each(|x| println!(&#34;{:?}&#34;, x.value().attr(&#34;src&#34;))); } 取得 html 文本 获取 document 对象 设置 selector 使用 document 解析 selector , 得到 ElementRef 结构体 对 ElementRef 进行操作 其中 document.select 返回一个数组 ElementRef ElementRef 又一个 value 方法 pub fn value(&amp;self) -&gt; &amp;&#39;a Element 而 Element 又是 pub struct Element { pub name: QualName, pub id: Option&lt;LocalName&gt;, pub classes: HashSet&lt;LocalName&gt;, pub attrs: Attributes, } 他有方法 pub fn attr(&amp;self, attr: &amp;str) -&gt; Option&lt;&amp;str&gt; 可以获取节点的属性值 当然，你如果想获取节点内部的文字信息，可以对 ElementRef 使用 pub fn inner_html(&amp;self) -&gt; String 美女爬虫例子 use std::{fs::File, io::Write}; use std::path::{Path, PathBuf}; use url::Url; const BASE_IMAGE_URL: &amp;str = &#34;https://meitulu.]]></description>
</item>
<item>
    <title>Serde Json 简单使用</title>
    <link>http://example.org/posts/2022/12/rust-serde-json/</link>
    <pubDate>Fri, 30 Dec 2022 17:59:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/12/rust-serde-json/</guid>
    <description><![CDATA[Serde Json 添加依赖 cargo add serde --features derive cargo add serde_json cargo add serde_derive 结构体的序列化与反序列化 use serde::{Serialize, Deserialize}; #[derive(Serialize, Deserialize, Debug)] struct Point { x: i32, y: i32, } fn main() { let point = Point {x: 1, y: 2}; let json: String = serde_json::to_string(&amp;point).unwrap(); println!(&#34;{}&#34;, json); let point: Point = serde_json::from_str(&amp;json).unwrap(); println!(&#34;{:#?}&#34;, point); } 枚举的序列化与反序列化 第一种枚举类型 参照结构体的序列化和反序列化，如果对一个枚举进行序列化，我们发现 use serde::{Serialize, Deserialize}; #[derive(Debug, Serialize, Deserialize)] enum Week { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, } fn main() { let json: String = serde_json::to_string(&amp;Week::Friday).]]></description>
</item>
<item>
    <title>Clap 简单使用</title>
    <link>http://example.org/posts/2022/12/rust-clap/</link>
    <pubDate>Fri, 23 Dec 2022 16:33:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/12/rust-clap/</guid>
    <description><![CDATA[添加参数 Basic 以 myapp run app --release --message hello 为例 这里的参数分为几种 run 子命令 app 固定位置参数 --release flag 参数 --message hello 命名选项参数 子命令 use clap::{Parser, Subcommand}; #[derive(Parser)] #[command(author, version, about, long_about = None)] struct Cli { #[command(subcommand)] command: Commands } #[derive(Subcommand)] enum Commands { Add { name: Option&lt;String&gt; } } fn main() { let cli = Cli::parse(); match &amp;cli.command { Commands::Add {name} =&gt; { println!(&#34;myapp add was used, name is: {:?}&#34;, name) } } } 在结构中使用 #[command(subcommand)] 表示以下结构是一个子命令 用 #[derive(Subcommand)] 来声明一个子命令结构 调用的时候，使用 myapp add hello 即可 固定位置参数 use clap::Parser; #[derive(Debug, Parser)] struct Cli { a: u32, b: u32, c: u32, name: String } fn main() { let cli = Cli::parse(); println!]]></description>
</item>
<item>
    <title>Rust 多线程程序和异步程序简单编写</title>
    <link>http://example.org/posts/2022/08/rust-multithread-async/</link>
    <pubDate>Thu, 18 Aug 2022 19:23:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/08/rust-multithread-async/</guid>
    <description><![CDATA[程序介绍 这次我打算把一个 select 多路复用的程序改成多线程版本和异步版本的，他的工作流程如下 从 stdin 读取数据，处理数据 从 socket 读取数据，处理数据 而多线程和异步版本的工作流程则是 创建数据通道 channel 创建一个 线程/Future, 从 stdin 读取数据，将数据写入 channel 创建一个 线程/Future, 从 socket 读取数据，将数据写入 channel 创建一个 线程/Future, 从 channel 读取数据，处理数据 我们马上来做一下看吧 多线程程序 从 socket 读取数据的线程 let thread1 = thread::spawn(move || { loop { let (mut stream, _) = server.accept().unwrap(); let mut received = String::new(); if let Err(_) = stream.read_to_string(&amp;mut received) { eprintln!(&#34;recv error occur&#34;); } if let Err(e) = sender1.send(received) { eprintln!]]></description>
</item>
<item>
    <title>共享单车</title>
    <link>http://example.org/posts/2022/08/bike/</link>
    <pubDate>Tue, 02 Aug 2022 19:38:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/08/bike/</guid>
    <description><![CDATA[共享单车 说明 这次的文章参考自 https://zhuanlan.zhihu.com/p/36776526 提出问题 某城市中共享单车出租的需求量如何 消费者的消费习惯 影响租车人数的因素 理解数据 导入数据 origindata = CSV.read(&#34;data/bike-sharing/train.csv&#34;, DataFrame) 查看数据集信息 describe(origindata) schema(data) 数据清洗 通过上面的数据查看，发现没有缺失值 数据类型转换 我们把 datetime 转换一下，转为 year month weekday day hour datetimes = map(x -&gt; DateTime(x, &#34;yyyy-mm-dd HH:MM:SS&#34;), dataframe[!, :datetime]) years = map(year, datetimes) months = map(month, datetimes) days = map(day, datetimes) weekdays = map(dayofweek, datetimes) hours = map(hour, datetimes) dataframe[!, :year] = years dataframe[!, :month] = months dataframe[!, :weekday] = weekdays dataframe[!, :day] = days dataframe[!]]></description>
</item>
<item>
    <title>电信用户流失分析</title>
    <link>http://example.org/posts/2022/07/telco/</link>
    <pubDate>Sat, 30 Jul 2022 21:43:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/07/telco/</guid>
    <description><![CDATA[电信用户流失分析 说明 这次文章的参考来自 https://zhuanlan.zhihu.com/p/68397317 提出问题 关于用户留存有这样一个观点，如果将用户流失率降低5%，公司利润将提升25%-85% 如今高居不下的获客成本让电信运营商遭遇“天花板”，甚至陷入获客难的窘境 随着市场饱和度上升，电信运营商亟待解决增加用户黏性，延长用户生命周期的问题 因此，电信用户流失分析与预测至关重要。 数据集来自 kaggle 理解数据 字段名 数据类型 字段描述 customerID String 顾客ID gender String 客户性别 SeniorCitizen Integer 客户是否为老年人 Partner String 客户是否有合作伙伴 Dependents String 客户是否有家属 tenure Integer 客户在公司停留的月数 PhoneService String 客户是否有电话服务 MultipleLines String 客户是否有多条路线 InternetService String 客户的互联网服务提供商 OnlineSecurity String 客户是否具有在线安全性 OnlineBackup String 客户是否有在线备份 DeviceProtection String 客户是否有设备保护 TechSupport String 客户是否有技术支持 StreamingTV String 客户是否有流媒体电视 StreamingMovies String 客户是否与流媒体电影 Contract String 客户的合同期限 PaperlessBilling String 客户是否有无纸化账单 PaymentMethod String 客户的支付方式 MonthlyCharges Integer 每月向客户收取的金额 TotalCharges Integer 向客户收取的总金额 Churn String 客户是否流失 数据清洗 首先导入数据 origindata = CSV.]]></description>
</item>
<item>
    <title>New York City Airbnb Open Data Analysis</title>
    <link>http://example.org/posts/2022/07/newyork/</link>
    <pubDate>Thu, 28 Jul 2022 14:23:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/07/newyork/</guid>
    <description><![CDATA[New York City Airbnb Open Data Analysis 以下流程参考自 https://www.kaggle.com/code/chirag9073/airbnb-analysis-visualization-and-prediction 导入库 using MLJFlux, Flux, MLJ, DataFrames, CSV, StatsBase using WordCloud 加载数据 origindata = CSV.read(&#34;data/newyork-city-airbnb-open-data/AB_NYC_2019.csv&#34;, DataFrame) 观察数据 你可以像教程那样 也可以，像我一样，用 excel 打开 csv 文件 我写了一个表格，记录我观察到的结果 column missing count type type coerce fill/drop id 0 Int Count =&gt; Continuous None name 16 String? Multiclass Drop host_id 0 Int Count =&gt; Continuous None host_name 21 String? Multiclass Drop neighbourhood_group 0 String15 Multiclass =&gt; Count =&gt; Continuous None neighbourhood 0 String31 Multiclass =&gt; Count =&gt; Continuous None latitude 0 Float64 Continuous None longitude 0 Float64 Continuous =&gt; Multiclass =&gt; Continuous None room_type 0 String15 Multiclass =&gt; Count =&gt; Continuous None price 0 Int Count =&gt; Continuous None minimum_nights 0 Int Count =&gt; Continuous None number_of_reviews 0 Int Count =&gt; Continuous None last_review 10052 Date?]]></description>
</item>
<item>
    <title>数据可视化 电影数据分析</title>
    <link>http://example.org/posts/2022/07/movies/</link>
    <pubDate>Thu, 28 Jul 2022 14:23:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/07/movies/</guid>
    <description><![CDATA[数据可视化 电影数据分析 说明 这次的文章参考自 https://zhuanlan.zhihu.com/p/35453189 提出问题 简单分析制作一部电影时，应考虑哪些客观因素才能使电影成功? 为客户提供有效的数据一句，以便作出更准确 的决策 本次数据分析报告主要围绕一下几点进行分析 问题一：电影类型如何随时间发生变化？ 电影数量上的对比 电影收入的对比 问题二：影响电影收入的客观因素有哪些？ 这个不会，先放一放 问题三：两家电影公司Universal Pictures 和 Paramount Pictures之间的对比。 电影发行数量上的对比 电影产生的利润对比 问题四：改编电影和原创电影之间的对比。 电影发行数量上的对比 电影产生的利润对比 理解数据 重点关注的变量有： imdb_id IMDB 标识号 popularity 在 Movie Database 上的相对页面查看次数 budget 预算（美元） revenue 收入（美元） original_title 电影名称 cast 演员列表，按 | 分隔，最多 5 名演员 homepage 电影首页的 URL director 导演列表，按 | 分隔，最多 5 名导演 tagline 电影的标语 keywords 与电影相关的关键字，按 | 分隔，最多 5 个关键字 overview 剧情摘要 runtime 电影时长 genres 风格列表，按 | 分隔，最多 5 种风格 production_companies 制作公司列表，按 | 分隔，最多 5 家公司 release_date 首次上映日期 vote_count 评分次数 vote_average 平均评分 release_year 发行年份 budget_adj 根据通货膨胀调整的预算（2010 年，美元） revenue_adj 根据通货膨胀调整的收入（2010 年，美元） 导入数据 using MLJFlux, Flux, MLJ, DataFrames, CSV, StatsBase, Dates import JSON creditsdata = CSV.]]></description>
</item>
<item>
    <title>Julia 简单爬虫编写</title>
    <link>http://example.org/posts/2022/07/julia-spider/</link>
    <pubDate>Sat, 23 Jul 2022 17:58:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/07/julia-spider/</guid>
    <description><![CDATA[项目介绍 我想试试 do everything in Julia，所以这里我简单写了一个爬虫，来爬取涩图 https://github.com/nesteiner/WebCrawl.jl 安装包 以下的包先安装好 HTTP 用于获取 HTTP Gumbo 用于解析 HTTP Cascadia 使用 CSS Selector 解析 HTTP URIs 用于uri 的解析 我们要爬取的 url 在这里 未成年人请在父母陪同下点击 工具函数 Julia 原有的 joinpath 不能满足我们的需求，比如我们要合并这两个 url https://example.com/hello /hello/1 合并后的结果应该是 https://example.com/hello/1 ，可 joinpath 合并后的结果是 /hello/1 这里我们使用 URIs 中的 resolvereference 来简单写一个 urljoin function urljoin(base::AbstractString, ref::AbstractString) return string( resolvereference(base, ref) ) end 整体流程 首先我们定义一个全局的 CONFIG 对象，来设置一些参数，比如 代理地址 请求头 Cookie User-Agent 我们再定义解析函数 parse ，由于处理方式与 scrapy 不太一样，没有必要将接口设计成一样 parse(startpage::String, dict::Dict{String, T}) where T &lt;: Any 由于出现分页，我们需要开始递归解析页面，我们从 startpage 开始解析， dict 存储一些额外参数，如 存储的文件夹位置 图片的名称 调用解析函数时，我们还会处理图片下载请求 pipeline(image::String, path::String) 他将从 image 下载资源，存储到 path 中 详细代码 参考 test/runtests.]]></description>
</item>
<item>
    <title>Android 数据绑定简单使用</title>
    <link>http://example.org/posts/2022/07/android-databinding/</link>
    <pubDate>Sat, 02 Jul 2022 14:39:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/07/android-databinding/</guid>
    <description><![CDATA[Android 数据绑定简单使用 这次我们要替代获取控件的方法，以前是使用 findViewById 一个一个拿到控件 现在我们需要直接在 layout 中注入数据对象，我们还要直接通过 id 访问到控件 数据绑定 启用数据绑定 在 build.gradle 中添加如下代码 android { dataBinding { enable = true } } 即可开启数据绑定 修改布局文件 先看 Vue 中的数据绑定是怎样操作的 &lt;template&gt; &lt;div class=&#34;container&#34;&gt; &lt;span&gt; {{data}} &lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&#34;ts&#34; setup&gt; const data = &#39;hello&#39; &lt;/script&gt; 在 XML 中 layout 类似 template 使用 data 标签声明数据 假设有数据类型 User public class User { public String name; public String password; public User(String name, String password) { this.]]></description>
</item>
</channel>
</rss>
