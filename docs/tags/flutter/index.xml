<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Flutter - Tag - My New Hugo Site</title>
        <link>http://example.org/tags/flutter/</link>
        <description>Flutter - Tag - My New Hugo Site</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 02 Jul 2022 01:43:00 &#43;0800</lastBuildDate><atom:link href="http://example.org/tags/flutter/" rel="self" type="application/rss+xml" /><item>
    <title>Flutter 中 provider 的使用</title>
    <link>http://example.org/post/2022/07/provider/</link>
    <pubDate>Sat, 02 Jul 2022 01:43:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/post/2022/07/provider/</guid>
    <description><![CDATA[Provider 的引入 Provider 解决的是组件之间传递数据的问题 在 Vue 中，父组件通过 props 传递数据给子组件，子组件通过 $emit 通知父组件，然后 Vue 重新渲染 DOM 在 Vue 中，也可以使用 provider 和 inject 传递数据，不过不能很好的处理响应性 与 Vue 相同的是，Flutter 的 Provider 的引入解决了数据传递中嵌套组件过多的问题，若在当前节点没有找到 Provider 组件， 则会通过上下文寻找 Provider ，直至找到 不过想使用 Provider，父组件得暴露出一个对象用以交互， 而这个对象得继承自 ChangeNotifier 以 ChangeNotifierProvider为例 ChangeNotifierProvider( builder: (context) =&gt; ExposedObject, child: ... ) 子组件想使用其中的值，得通过 Consumer 组件或者 context.read&lt;ExposedType&gt; Consumer( create: (context, ExposedType expose, child) { // call expose } ) var expose = context.read&lt;ExposedType&gt;(); 注意 除了 context.read 外，还有 context.]]></description>
</item>
<item>
    <title>Flutter Counter</title>
    <link>http://example.org/post/2022/07/counter/</link>
    <pubDate>Sat, 02 Jul 2022 01:42:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/post/2022/07/counter/</guid>
    <description><![CDATA[如何写一个 Flutter 应用 我们从一个计数器讲起， 首先建立 Counter 类 class Counter extends StatelessWidget { Counter(): super(); @override Widget build(BuildContext context) { // TODO: implement build return MaterialApp( title: &#39;Flutter Counter&#39;, theme: ThemeData(primarySwatch: Colors.blue), home: CounterHomePage(title: &#39;Flutter Counter Home Page&#39;), ); } } 在内部定义了构造方法，并且重构了 build 方法 其中 build 方法返回了一个 MaterialApp ，这就是 Flutter 提供的根组件，接下来只需提供一个 Widget ，将其赋值给 home 作为主页程序即可 再来看看赋值 home 的组件 CounterHomePage 是怎么写的 class CounterHomePage extends StatefulWidget { CounterHomePage({this.title = &#39;Hello World&#39;}): super(); String title; @override CounterHomePageState createState() =&gt; CounterHomePageState(); } 这个类继承自 StatefulWidget ，与 Counter 类继承的 StatelessWidget 成对比， Counter 是无状态的组件， CounterHomePage 是有状态的组件 其中重写了 StatefulWidget 的 createState 方法，返回值是用来管理其状态的 CounterHomePageState class CounterHomePageState extends State&lt;CounterHomePage&gt; { int count = 0; void incrementCount() { setState(() { count += 1; }); } @override Widget build(BuildContext context) { // TODO: implement build return Scaffold( appBar: AppBar(title: Text(widget.]]></description>
</item>
</channel>
</rss>
