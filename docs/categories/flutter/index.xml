<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Flutter - Category - My New Hugo Site</title>
        <link>http://example.org/categories/flutter/</link>
        <description>Flutter - Category - My New Hugo Site</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 02 Jul 2022 01:44:00 &#43;0800</lastBuildDate><atom:link href="http://example.org/categories/flutter/" rel="self" type="application/rss+xml" /><item>
    <title>在 Flutter 中使用数据库</title>
    <link>http://example.org/post/2022/07/flutter_database/</link>
    <pubDate>Sat, 02 Jul 2022 01:44:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/post/2022/07/flutter_database/</guid>
    <description><![CDATA[在 Flutter 中使用数据库 介绍 以 sqlite 为例，flutter 在使用数据库时需要引入 sqflite 依赖 dependencies: flutter: sdk: flutter sqflite: 导入 package:sqflite/sqflite.dart 与 package:sqflite/sql.dart 后，可以在 openDatabase 中的 onCreate 参数中设置初始化 openDatabase( &#39;file:///home/steiner/workspace/playground/todolist/todolist.db&#39;, onCreate: (database, version) async { await database.execute( &#39;create table if not exists TaskList(&#39; &#39;id integer primary key autoincrement,&#39; &#39;name text not null&#39; &#39;);&#39; ); }, version: 1 ); 其余数据库操作参考 中文文档 组件中使用数据库 由于在 Dart 中数据库的操作是异步的，返回值是 Future 类型，对 Future 使用 await 需要在异步函数中进行， 各个组件的 build 方法又是同步的，无法使用 Future 不过 flutter 提供了 FutureBuilder 组件，为其提供 futurue 选项来构造组件 FutureBuilder({ this.]]></description>
</item>
<item>
    <title>Flutter 中 provider 的使用</title>
    <link>http://example.org/post/2022/07/provider/</link>
    <pubDate>Sat, 02 Jul 2022 01:43:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/post/2022/07/provider/</guid>
    <description><![CDATA[Provider 的引入 Provider 解决的是组件之间传递数据的问题 在 Vue 中，父组件通过 props 传递数据给子组件，子组件通过 $emit 通知父组件，然后 Vue 重新渲染 DOM 在 Vue 中，也可以使用 provider 和 inject 传递数据，不过不能很好的处理响应性 与 Vue 相同的是，Flutter 的 Provider 的引入解决了数据传递中嵌套组件过多的问题，若在当前节点没有找到 Provider 组件， 则会通过上下文寻找 Provider ，直至找到 不过想使用 Provider，父组件得暴露出一个对象用以交互， 而这个对象得继承自 ChangeNotifier 以 ChangeNotifierProvider为例 ChangeNotifierProvider( builder: (context) =&gt; ExposedObject, child: ... ) 子组件想使用其中的值，得通过 Consumer 组件或者 context.read&lt;ExposedType&gt; Consumer( create: (context, ExposedType expose, child) { // call expose } ) var expose = context.read&lt;ExposedType&gt;(); 注意 除了 context.read 外，还有 context.]]></description>
</item>
<item>
    <title>Flutter 中的Router</title>
    <link>http://example.org/post/2022/07/router/</link>
    <pubDate>Sat, 02 Jul 2022 01:43:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/post/2022/07/router/</guid>
    <description><![CDATA[用你的应用来演示 路由用法 在这个演示里定义两个界面，HomePage 与 NextPage ，并从 HomePage 传递参数到 NextPage 中 接下来演示匿名路由和命名路由的情况 这是 HomePage 点击文字按钮后，跳转到 NextPage 1. 匿名路由跳转 首先是 HomePage class HomePage extends StatelessWidget { Widget buildBody(BuildContext context) { var fnpress = (String message) { return () { Navigator.push(context, MaterialPageRoute(builder: (builder) =&gt; NextPage(message: message))); }; }; return Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ TextButton(onPressed: fnpress(&#39;Hello World&#39;), child: Text(&#39;goto the next page with status 1&#39;)), TextButton(onPressed: fnpress(&#39;Fuck You&#39;), child: Text(&#39;goto the next page with status 2&#39;)) ], ), ); } @override Widget build(BuildContext context) { // TODO: implement build return Scaffold( appBar: AppBar(title: Text(&#39;Home Page&#39;),), body: buildBody(context), ); } } 在跳转时通过构造函数来传递参数，其中 NextPage 为 class NextPage extends StatelessWidget { String message; NextPage({required this.]]></description>
</item>
<item>
    <title>Flutter Counter</title>
    <link>http://example.org/post/2022/07/counter/</link>
    <pubDate>Sat, 02 Jul 2022 01:42:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/post/2022/07/counter/</guid>
    <description><![CDATA[如何写一个 Flutter 应用 我们从一个计数器讲起， 首先建立 Counter 类 class Counter extends StatelessWidget { Counter(): super(); @override Widget build(BuildContext context) { // TODO: implement build return MaterialApp( title: &#39;Flutter Counter&#39;, theme: ThemeData(primarySwatch: Colors.blue), home: CounterHomePage(title: &#39;Flutter Counter Home Page&#39;), ); } } 在内部定义了构造方法，并且重构了 build 方法 其中 build 方法返回了一个 MaterialApp ，这就是 Flutter 提供的根组件，接下来只需提供一个 Widget ，将其赋值给 home 作为主页程序即可 再来看看赋值 home 的组件 CounterHomePage 是怎么写的 class CounterHomePage extends StatefulWidget { CounterHomePage({this.title = &#39;Hello World&#39;}): super(); String title; @override CounterHomePageState createState() =&gt; CounterHomePageState(); } 这个类继承自 StatefulWidget ，与 Counter 类继承的 StatelessWidget 成对比， Counter 是无状态的组件， CounterHomePage 是有状态的组件 其中重写了 StatefulWidget 的 createState 方法，返回值是用来管理其状态的 CounterHomePageState class CounterHomePageState extends State&lt;CounterHomePage&gt; { int count = 0; void incrementCount() { setState(() { count += 1; }); } @override Widget build(BuildContext context) { // TODO: implement build return Scaffold( appBar: AppBar(title: Text(widget.]]></description>
</item>
</channel>
</rss>
