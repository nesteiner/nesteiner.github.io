<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Rust - Category - My New Hugo Site</title>
        <link>http://example.org/categories/rust/</link>
        <description>Rust - Category - My New Hugo Site</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 30 Dec 2022 17:59:00 &#43;0800</lastBuildDate><atom:link href="http://example.org/categories/rust/" rel="self" type="application/rss+xml" /><item>
    <title>Serde Json 简单使用</title>
    <link>http://example.org/posts/2022/12/rust-serde-json/</link>
    <pubDate>Fri, 30 Dec 2022 17:59:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/12/rust-serde-json/</guid>
    <description><![CDATA[Serde Json 添加依赖 cargo add serde --features derive cargo add serde_json cargo add serde_derive 结构体的序列化与反序列化 use serde::{Serialize, Deserialize}; #[derive(Serialize, Deserialize, Debug)] struct Point { x: i32, y: i32, } fn main() { let point = Point {x: 1, y: 2}; let json: String = serde_json::to_string(&amp;point).unwrap(); println!(&#34;{}&#34;, json); let point: Point = serde_json::from_str(&amp;json).unwrap(); println!(&#34;{:#?}&#34;, point); } 枚举的序列化与反序列化 第一种枚举类型 参照结构体的序列化和反序列化，如果对一个枚举进行序列化，我们发现 use serde::{Serialize, Deserialize}; #[derive(Debug, Serialize, Deserialize)] enum Week { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, } fn main() { let json: String = serde_json::to_string(&amp;Week::Friday).]]></description>
</item>
<item>
    <title>Clap 简单使用</title>
    <link>http://example.org/posts/2022/12/rust-clap/</link>
    <pubDate>Fri, 23 Dec 2022 16:33:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/12/rust-clap/</guid>
    <description><![CDATA[添加参数 Basic 以 myapp run app --release --message hello 为例 这里的参数分为几种 run 子命令 app 固定位置参数 --release flag 参数 --message hello 命名选项参数 子命令 use clap::{Parser, Subcommand}; #[derive(Parser)] #[command(author, version, about, long_about = None)] struct Cli { #[command(subcommand)] command: Commands } #[derive(Subcommand)] enum Commands { Add { name: Option&lt;String&gt; } } fn main() { let cli = Cli::parse(); match &amp;cli.command { Commands::Add {name} =&gt; { println!(&#34;myapp add was used, name is: {:?}&#34;, name) } } } 在结构中使用 #[command(subcommand)] 表示以下结构是一个子命令 用 #[derive(Subcommand)] 来声明一个子命令结构 调用的时候，使用 myapp add hello 即可 固定位置参数 use clap::Parser; #[derive(Debug, Parser)] struct Cli { a: u32, b: u32, c: u32, name: String } fn main() { let cli = Cli::parse(); println!]]></description>
</item>
<item>
    <title>Rust 多线程程序和异步程序简单编写</title>
    <link>http://example.org/posts/2022/08/rust-multithread-async/</link>
    <pubDate>Thu, 18 Aug 2022 19:23:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/2022/08/rust-multithread-async/</guid>
    <description><![CDATA[程序介绍 这次我打算把一个 select 多路复用的程序改成多线程版本和异步版本的，他的工作流程如下 从 stdin 读取数据，处理数据 从 socket 读取数据，处理数据 而多线程和异步版本的工作流程则是 创建数据通道 channel 创建一个 线程/Future, 从 stdin 读取数据，将数据写入 channel 创建一个 线程/Future, 从 socket 读取数据，将数据写入 channel 创建一个 线程/Future, 从 channel 读取数据，处理数据 我们马上来做一下看吧 多线程程序 从 socket 读取数据的线程 let thread1 = thread::spawn(move || { loop { let (mut stream, _) = server.accept().unwrap(); let mut received = String::new(); if let Err(_) = stream.read_to_string(&amp;mut received) { eprintln!(&#34;recv error occur&#34;); } if let Err(e) = sender1.send(received) { eprintln!]]></description>
</item>
</channel>
</rss>
